package com.java_face_detection;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

//opencv
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.videoio.VideoCapture;

import application.Range;


/******NOTE: Only using opencv to stream video from web cam******/


public class ColorDetector {

	static Range r = new Range();
	
	static List<Point> list = new ArrayList<Point>();
	static List<ColorBlob> blobList = new ArrayList<ColorBlob>();
	
	public static void main(String[] args) throws Exception{
		
		//BufferedImage src = ImageIO.read(new File("C:\\Users\\Ramesh\\Desktop\\lid.jpg"));
		
		//ImageIO.write(trackCol(src), "jpg", new File("C:\\Users\\Ramesh\\Desktop\\outt.jpg"));
		
		startVideoStream();
	}

	private static void startVideoStream() {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
		
		Mat frame = new Mat();
	    //0; for main web cam
	    VideoCapture camera = new VideoCapture(0);
	    
	    JFrame jframe = new JFrame("Color Tracker");
	    jframe.setSize(400, 400);
	    jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    jframe.setVisible(true);
	    
	    JLabel vidpanel = new JLabel();
	    vidpanel.setBounds(0, 0, 400, 400);
	    
	    jframe.setContentPane(vidpanel);
	    
	    /**null layout: if not null (when not using any layout manager),
	    on resizing screen button will go full screen*/
	    jframe.setLayout(null);
		
	    new Thread(new Runnable() {
			
			@Override
			public void run() {
				while (true) {
			        if (camera.read(frame)) {
			            
			            try {
							vidpanel.setIcon(new ImageIcon(trackCol(Mat2BufferedImage(frame))));
						} catch (Exception e1) {
							e1.getMessage();
						}
			            
			            vidpanel.repaint();

			        }
			    }
			}
		}).start();
		
	}
	
	//converting the matrix generated by open CV to buffered image
	static BufferedImage Mat2BufferedImage(Mat matrix)throws Exception {        
	    MatOfByte mob = new MatOfByte();
	    Imgcodecs.imencode(".jpg", matrix, mob);
	    byte ba[] = mob.toArray();

	    BufferedImage bi = ImageIO.read(new ByteArrayInputStream(ba));
	    
	    return bi;
	}
	
	/*
	 * the code that tracks specified color
	 * pass the color you want to track on -> trackCol
	 * 
	 * parameter src accepts the img on which you want to track color
	 * */
	public static BufferedImage trackCol(BufferedImage src) {
		
		int h = src.getHeight();
		int w = src.getWidth();
		
		BufferedImage copy = new BufferedImage(w, h, src.getType());
		
		//eg: orange color
		//Color trackCol = new Color(255,165,0);
		
		//eg: green color
		//Color trackCol = new Color(0,128,0);
		
		//eg: red color
		Color trackCol = new Color(190, 0, 0);
		
		//eg: blue color
		//Color trackCol = new Color(0, 0, 128);
		
		Color col;
		double diff;
		
		int startX = 0, startY = 0;
		
		//int count = 0;

		int latestX = 0, latestY = 0;
		
		
		
		for(int y=0;y<h;y++) {
			for(int x=0;x<w;x++) {
				
				col = new Color(src.getRGB(x, y));
				
				diff = dist(trackCol.getRed(), trackCol.getGreen(), trackCol.getBlue(),
						col.getRed(), col.getGreen(), col.getBlue());
				
				/*if the euclidian dist between two colors is in range hundered then
				*those colors come close and seems same
				*/
				if(r.is(diff).inRange(0, 100)) {
					
					list.add(new Point(x, y));
					
					if((x < startX) && (y < startY)) {
						startX = x;
						startY = y;
						
					}
					
					if(startX == 0 && startY == 0) {
						startX = x;
						startY = y;
					}
					
					//marking pixel as the recently discovered 
					//tracking color
					latestX = x;
					latestY = y;
					
					int index = list.size() - 2;
					float pixDist = pixelDist(list.get(index).x, list.get(index).y,
							latestX, latestY);
					
					if(pixDist > 20) {
						blobList.add(new ColorBlob(src, latestX, latestY));
					}
					
					copy.setRGB(x, y, trackCol.getRGB());
					
				}
				else
					copy.setRGB(x, y, new Color(0, 0, 0).getRGB());
			}
		}
		
		blobList.add(new ColorBlob(src, startX, startY));
		
		return drawRect(src, blobList);
	}
	
	//graphics2d to draw box on blob
	static BufferedImage drawRect(BufferedImage img, List<ColorBlob> l) {
		Graphics2D g2d = img.createGraphics();
		
		g2d.setPaint(Color.WHITE);
		
		for(ColorBlob blob: l)
			g2d.drawRect(blob.x, blob.y, 50, 50);
		
		list.clear();
		blobList.clear();
		
		return img;
	}
	
	/*calcs the new pixel dist from the latest trackCol discovered pixel.
	 * If its dist from latest pixel is less than 5-10,
	 * they will be in same blob
	*/
	static float pixelDist(float x1, float y1, float x2, float y2) {
		return (float) Math.sqrt(((x2-x1)*2) + ((y2-y1)*2));
	}
	
	//euclidian distance of two RGB_color_space
	static double dist(double r1, double g1, double b1, double r2, double g2, double b2) {	
		return Math.sqrt(Math.pow((r1-r2), 2) + Math.pow((b1-b2), 2) + Math.pow((g1-g2), 2));
	}

}
